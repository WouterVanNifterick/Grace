unit eeDFT;

interface

uses
  VamLib.MoreTypes;

procedure CalcDFT(Input:TArrayOfSingle; Output:TArrayOfComplex; SampleFrames:integer);

procedure CalcInverseDFT(Input:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);

procedure CalcMagnitudes(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
procedure CalcMagnitudes_Normalised(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);

procedure CalcPhases(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);



implementation

uses
  Math, eeDFTUtils;

// Procedure DFT(Input:TArrayOfSingle; Output:TArrayOfComplex; SampleFrames:integer);
//
// Input - array of 'real' values.
// Output - array of complex values.
// SampleFrames - DFT analysis length.

procedure CalcDFT(Input:TArrayOfSingle; Output:TArrayOfComplex; SampleFrames:integer);
var
  m,n:integer;
  tx:single;
  OneOverFrames:single;
  RealSum:single;
  ImagSum:single;
  ScaleFactor:single;
begin

  OneOverFrames := 1 / SampleFrames;

  //Use this scale factor to keep maintain scale when calculating DFT and InverseDFT.
  ScaleFactor := 1 / sqrt(SampleFrames);

  //Use this scale factor to scale values to 1/2 half of their correct value.
  //ScaleFactor := 1 / SampleFrames;

  for m := 0 to SampleFrames - 1 do
  begin
    RealSum := 0;
    ImagSum := 0;

    for n := 0 to SampleFrames - 1 do
    begin
      tx := 2 * PI * n * m * OneOverFrames;

      RealSum := RealSum + Input[n] * cos(tx);
      ImagSum := ImagSum + Input[n] * sin(tx);
    end;

    Output[m].Real := ScaleFactor * RealSum;
    Output[m].Imag := ScaleFactor * ImagSum;
  end;

end;

procedure CalcInverseDFT(Input:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
var
  m,n:integer;
  tx:single;
  OneOverFrames:single;
  RealSum:single;
  ImagSum:single;
  ScaleFactor:single;
begin

  OneOverFrames := 1 / SampleFrames;

  //Use this scale factor to keep maintain scale when calculating DFT and InverseDFT.
  ScaleFactor := 1 / sqrt(SampleFrames);

  //Use this scale factor to scale values to 1/2 half of their correct value.
  //ScaleFactor := 1 / SampleFrames;

  for m := 0 to SampleFrames - 1 do
  begin
    RealSum := 0;

    for n := 0 to SampleFrames - 1 do
    begin
      tx := 2 * PI * n * m * OneOverFrames;

      RealSum := RealSum + (Input[n].Real * cos(tx)) + (Input[n].Imag * sin(tx));
    end;

    Output[m] := ScaleFactor * RealSum;

  end;

end;

procedure CalcMagnitudes(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
var
  m:integer;
begin
  {
  for m := 0 to SampleFrames - 1 do
  begin
    Output[m] := sqrt(DftData[m].Real * DftData[m].Real + DftData[m].Imag * DftData[m].Imag);
  end;
  }

  for m := 0 to SampleFrames - 1 do
  begin
    Output[m] := CalcMagnitude(DftData[m]);
  end;

end;

// procedure CalcMagnitudes_Normalised(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
//
// This method looks at the frequency/phase data generated by the DFT and calculates the
// magnitude of each bin. Magnitudes are normalised to a 1 to 1 scale.
procedure CalcMagnitudes_Normalised(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
var
  m:integer;
  ScaleFactor:single;
begin
  ScaleFactor := sqrt(SampleFrames) * 2 / SampleFrames;

  {
  for m := 0 to SampleFrames - 1 do
  begin
    Output[m] := sqrt(DftData[m].Real * DftData[m].Real + DftData[m].Imag * DftData[m].Imag) * ScaleFactor;
  end;
  }

  for m := 0 to SampleFrames - 1 do
  begin
    Output[m] := CalcMagnitude(DftData[m]) * ScaleFactor;
  end;
end;

procedure CalcPhases(DFTData:TArrayOfComplex; Output:TArrayOfSingle; SampleFrames:integer);
var
  m:integer;
begin
  for m := 0 to SampleFrames - 1 do
  begin
    Output[m] := CalcPhase(DftData[m]);
  end;
end;





end.
